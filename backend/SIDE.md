Insight Platform
Keep these things in mind, I need to update the frontend and backend and the database to include these new changes.
There are two user roles:
Admin
* Full CRUD access to:
    * All users
    * All albums
    * All images
* Can manage system-owned resources (Gallery, moderation, metadata fixes, etc.)
User
* Can CRUD only their own:
    * Albums
    * Images
* Can view, share, and download:
    * All images in the Gallery
    * Albums created by other users
* Cannot modify or delete other users’ content but can add other users images to albums they have created
* Avatar

USERS
Users are the core entity that owns albums and images.
Relationships
* One-to-many → Users → Albums
* One-to-many → Users → Images
* One-to-many → Users → Share Links
* One-to-many → Users → Image Favorites
Fields
* id
* username
* email
* avatar
* cognito_sub (future authentication source)
* role (admin | user)
* first_name
* last_name
* profile_metadata (JSON for extensibility)
* created_at
* updated_at

GALLERY
Description
The Gallery is a single, system-controlled collection that contains every image uploaded by any user or admin.
* All images live in the Gallery by default
* The Gallery cannot be deleted
* Images in the Gallery:
    * Are searchable by user-generated tags, AWS Rekognition tags, title, description words, date the photo was taken
    * Are visible to all users
    * Are downloadable (permissions apply)
* The Gallery is not owned by a user, but images inside it are

ALBUMS
Albums are user-curated collections of images.
Rules
* Every user can CRUD their own albums
* Admins can CRUD any album
* Albums are publicly viewable
* Albums do not own images — they reference them
* A user can have multiple albums
* An album can contain many images
* An image can belong to multiple albums
* Albums may be shared via share links
Relationships
* One-to-many → User → Albums
* Many-to-many → Albums ↔ Images
Fields
* id
* title
* description
* owner_user_id (FK → users.id)
* is_master (boolean, default False — reserved for system use if needed)
* share_link (optional, managed via Share Links system)
* created_at
* updated_at

IMAGES
Images are the primary content object of the platform.
Rules
* Every user can CRUD their own images
* Admins can CRUD all images
* All images:
    * Always exist in the Gallery
    * May or may not belong to one or more albums
    * Are visible and downloadable by all users
* Images can be:
    * Associated with an album at upload
    * Added to albums later
* Every image can be shared via a share link
* Watermarking can be enabled or disabled per share

Relationships
* One-to-many → User → Images
* Many-to-many → Images ↔ Albums
* Many-to-many → Images ↔ Tags
* One-to-many → Image → Share Links
* One-to-many → Image → Favorites (per user)

Fields
* id
* uploader_user_id (FK → users.id)
Storage
* s3_key (original image location)
* preview_key (optimized preview image)
Metadata
* title
* description
* metadata (JSON for EXIF & extended data)
* aws_tags (array or relation — generated by AWS Rekognition)
* user_tags (array or relation — user defined)
Camera / Location Data
* camera_make
* camera_model
* lens
* focal_length
* aperture
* shutter_speed
* iso
* gps_latitude
* gps_longitude
* location_name (derived or reverse-geocoded)
* metadata JSONB   -- full EXIF + misc
Dates
* captured_at (date image was taken by camera)
* created_at (upload date)
* updated_at
Sharing & Protection
* watermark_enabled (boolean, applied at share-time)

TAGS
Tags are normalized, reusable descriptors attached to images.
Rules
* Tags can originate from:
    * User input
    * AWS Rekognition
* Tags are searchable across the Gallery
* Tags are shared across images (no duplication of tags on a single image)
Fields
* id
* name
* source (user | aws)
* created_at

IMAGE_ALBUMS (Join Table)
Purpose
Associates images with albums.
Fields
* image_id (FK → images.id)
* album_id (FK → albums.id)

IMAGE_FAVORITES
Purpose
Allows users to save images for quick access.
Rules
* Favorites are per-user
* Favoriting does not affect image ownership or visibility
Fields
* user_id (FK → users.id)
* image_id (FK → images.id)
* created_at

SHARE_LINKS
Description
Share links provide controlled access to albums or images.
Rules
* Can be created for:
    * A single image
    * An entire album
* Can expire
* Can optionally enforce watermarking
* Can be revoked
* Can be reused
Fields
* id
* resource_type (album | image)
* resource_id (FK → albums.id or images.id)
* owner_user_id (FK → users.id)
* token (unique, unguessable)
* link (full URL)
* expires_at
* created_at
* updated_at

AWS RESPONSIBILITIES (Clarified)
* S3 → stores image originals & previews only
* Database → stores:
    * Metadata
    * Albums
    * Relationships
    * Tags
    * Share logic
* AWS Rekognition → generates image tags (non-authoritative, supplemental)

Final Clarifications (Intent Locked In)
* ✅ Images do not need to belong to an album
* ✅ Albums never own images
* ✅ Gallery always contains everything
* ✅ Images always have:
    * Title
    * Description
    * Camera info
    * Location (when available)
    * Capture date
    * Upload date
* ✅ Watermarking applies only when sharing, not to originals

AWS RULES
You do NOT store avatars or album images as Base64 in the database. You store files in S3 and only store references (keys / URLs) in the DB.
That applies to:
* ✅ user avatars
* ✅ album cover images
* ✅ gallery images
* ✅ previews / thumbnails

S3 is the source of truth for image data.
You upload:
* original image
* preview image (optional)
* album cover
* avatar
S3 returns:
* s3_key
* s3_url (or signed URL later)

DATABASE STORES ONLY METADATA No Base64. No blobs. No files.

3️⃣ S3 KEY STRUCTURE (VERY IMPORTANT)

✅ User avatars
avatars/{user_id}/avatar.jpg

✅ Album cover images
album_images/cover.jpg

✅ Gallery images
gallery/originals/{uuid}.jpg
gallery/previews/{uuid}.jpg


WHERE BASE64 IS ALLOWED (LIMITED CASE)
We agreed Base64 is only acceptable when:
✅ The frontend already has a Base64 image (e.g. canvas export) ✅ You immediately convert it to a file and upload to S3 ❌ You do NOT store the Base64 string permanently
Your upload_base64_to_s3() helper exists only for that — not as a storage strategy.

2a. What belongs in api.js
Anything that interacts with the backend or S3 should live in api.js. You already have:
* getImages()
* getImage()
* uploadImage(file, title, description, albumIds, userTags)
* updateImage()
* deleteImage()
* addImageToAlbum() / removeImageFromAlbum()
✅ So all API calls stay in api.js. Images.jsx calls them already.

2b. What belongs in UserDataContext.jsx
The context should store shared state or user-scoped logic:
* imagesCount ✅ (already present)
* setImagesCount ✅ (already present)
* canEditImage(image) ✅ (already present)
* userImages (images uploaded by current user) → this can be added to context if multiple components need it.
* Optionally, search/filter logic could also be centralized, but it’s usually fine in the page.
Why move user-specific image state to context?
* Avoid refetching in multiple pages.
* Keep counts and permissions in sync.
* Centralize upload updates (setImagesCount and userImages).

